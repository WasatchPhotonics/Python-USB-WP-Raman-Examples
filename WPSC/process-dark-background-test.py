#!/usr/bin/env python
"""
This script is provided to post-process DarkBackgroundTest.csv files generated by
WPSC. Those files typically provide 100ea dark spectra at multiple integration 
times, such as 10, 100 and 1000ms. It also may include dark spectra collected 
while the laser is OFF vs when the laser is ON.

This script applies an FFT to each dark spectrum to look for sinusoidal pattern 
noise (for instance, being leaked into the detector readout from the laser 
electronics).

This script is not considered production-ready for any particular purpose, and is
only recommended for quick-and-dirty R&D analysis or as an example of how Python
scripts can leverage ENLIGHTEN classes to quickly load WPSC files.

invocation:

$ export PYTHONPATH=$HOME/work/code/enlighten:$HOME/work/code/Wasatch.PY:$HOME/work/code/jcamp:$HOME/work/code/SPyC_Writer
$ python process-dark-background-test.py file.csv

"""

import re, os, sys, math, logging, argparse
import numpy as np
import matplotlib.pyplot as plt

from enlighten.parser.ExportFileParser import ExportFileParser
from wasatch import applog

args = None

def process_fft(a, label):
    """ 
    Return numerically sorted list of non-zero FFT frequencies, and a matching 
    list of evaluated magnitudes corresponding to those frequencies.
    """
    # generate the list of frequencies
    len_ = len(a)
    freqs = np.fft.fftfreq(len_)

    # generate and evaluate the per-frequency magnitudes
    data = np.fft.fft(a)
    mags = np.array( [ math.sqrt( v.real * v.real + v.imag * v.imag ) for v in data ] )

    # pop the zero'th element -- this simply contains the sum of all pixels and 
    # provides no useful frequency data
    freqs = freqs[1:]
    mags = mags[1:]

    # sort both lists by freq in ascending order
    indices = np.argsort(freqs)
    freqs = freqs[indices]
    mags = mags[indices]

    # graphing
    if args.plot:
        plt.clf()
        fig, (spectrum, analysis) = plt.subplots(1, 2, figsize=(15, 5))
        fig.suptitle(label)
        spectrum.plot(a)
        analysis.plot(freqs, mags)
        plt.draw()
        plt.pause(1)
        plt.close(fig)

    return freqs, mags

# parse command-line arguments
parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument("--plot", action="store_true", help="graph FFT")
(args, filenames) = parser.parse_known_args(sys.argv[1:])

if args.plot:
    plt.ion()

filename = filenames[0]
basename = re.sub(r'\.csv', '', filename)

# use ENLIGHTEN to parse WPSC report
efp = ExportFileParser(ctl=None, pathname=filename)
measurements = efp.parse()

# generate report of FFTs for each spectrum
groups = {}
with open(f"table-{basename}.csv", "w") as outfile:
    # header row
    outfile.write("measurement, len, sum, avg, stdev, rms, model, label, ")
    finished_header = False

    # now output all measurements, including key freqs
    for i, m in enumerate(measurements):
        label = m.label.replace(',', '_')
        model = m.settings.eeprom.model
        pr    = m.processed_reading
        raw   = np.array(pr.raw)

        # basic stats on the raw spectrum
        len_  = len(raw)
        sum_  = sum(raw)
        avg   = np.mean(raw)
        stdev = np.std(raw)
        rms   = np.sqrt(np.mean(raw**2))

        # generate FFT
        freqs, mags = process_fft(raw, label)

        if not finished_header:
            outfile.write(", ".join([f"freq {x:.3f}" for x in freqs]))
            outfile.write("\n")
            finished_header = True

        outfile.write(f"{i}, {len_}, {sum_:.2f}, {avg:.2f}, {stdev:.2f}, {rms:.2f}, {model}, {label}, " + ", ".join([f"{x:0.2f}" for x in mags]) + "\n")

        # collect all FFT magnitudes for later aggregate reporting
        group = re.sub(r' -.*', '', label)
        if group not in groups:
            groups[group] = []
        groups[group].append(mags)

# produce aggregate summary
with open(f"fft-summary-{basename}.csv", "w") as outfile:
    # header row
    outfile.write("group, " + ", ".join([f"{x:0.3f}" for x in freqs]) + "\n")

    # median magnitudes
    for group in groups:
        mags = np.array(groups[group])
        medians = np.median(mags, axis=0)
        outfile.write(f"{group}-med, " + ", ".join([f"{x:0.2f}" for x in medians]) + "\n")

    # max magnitudes
    for group in groups:
        mags = np.array(groups[group])
        maxes = np.max(mags, axis=0)
        outfile.write(f"{group}-max, " + ", ".join([f"{x:0.2f}" for x in maxes]) + "\n")
