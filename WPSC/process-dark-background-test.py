#!/usr/bin/env python
"""
This script is provided to post-process DarkBackgroundTest.csv files generated by
WPSC. Those files typically provide 100ea dark spectra at multiple integration 
times, such as 10, 100 and 1000ms. It also may include dark spectra collected 
while the laser is OFF vs when the laser is ON.

This script applies an FFT to each dark spectrum to look for frequencies with 
unusually high magnitudes, indicating pattern noise (for instance, being leaked
into the dark from the laser electronics).

This script is not considered production-ready for any particular purpose, and is
only recommended for quick-and-dirty R&D analysis or as an example of how Python
scripts can leverage ENLIGHTEN classes to quickly load WPSC files.

invocation:

$ export PYTHONPATH=$HOME/work/code/enlighten:$HOME/work/code/Wasatch.PY:$HOME/work/code/jcamp:$HOME/work/code/SPyC_Writer
$ python process-dark-background-test.py file.csv

"""

import re, os, sys, logging, argparse
import numpy as np
import matplotlib.pyplot as plt

from enlighten.parser.ExportFileParser import ExportFileParser
from wasatch import applog

args = None

def process_fft(a, n=5, label="UNKNOWN"):
    """ Return a dict of {freq -> mag} for top n magnitudes (positive frequencies only) """
    len_ = len(a)
    data = np.fft.fft(a)
    mags = np.abs(data)
    freqs = np.fft.fftfreq(len_)

    # print(f"mags:  " + ", ".join([f"{x:.2f}" for x in mags]))
    # print(f"freqs: " + ", ".join([f"{x:.2f}" for x in freqs]))

    # only consider positive frequencies (they are emitted from +max..zero..-max)

    pos_freq_idx = np.where(freqs > 0)
    pos_freqs = freqs[pos_freq_idx]
    pos_mags = mags[pos_freq_idx]

    if args.plot and "laser" in label.lower():
        plt.clf()
        fig, (ax2, ax3) = plt.subplots(1, 2, figsize=(15, 5))
        fig.suptitle(label)
        # ax1.plot(freqs, mags)
        ax2.plot(pos_freqs, pos_mags)
        ax3.plot(a)
        plt.draw()
        plt.pause(1)
        plt.close(fig)

    # we only want the top "n" magnitudes, so sort in reverse numeric order by magnitude 
    top_mag_idx = np.argsort(pos_mags)
    top_mags = np.array(pos_mags)[top_mag_idx]
    top_freq = np.array(pos_freqs)[top_mag_idx]

    # return the top 'n' key-value pairs
    result = dict(zip(top_freq[:n], top_mags[:n]))
    return result

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument("--plot", action="store_true", help="graph FFT")
(args, filenames) = parser.parse_known_args(sys.argv[1:])

if args.plot:
    plt.ion()

filename = filenames[0]
basename = re.sub(r'\.csv', '', filename)
efp = ExportFileParser(ctl=None, pathname=filename)
measurements = efp.parse()

# determine the top FFT frequencies across all measurements
key_freqs = set()
for m in measurements:
    pr = m.processed_reading
    proc = np.array(pr.processed)
    m.freq_mags = process_fft(proc, label=m.label)
    for freq in m.freq_mags:
        key_freqs.add(round(freq, 2))
key_freqs = list(key_freqs)
key_freqs.sort()

group_freqs = {}
with open(f"table-{basename}.csv", "w") as outfile:
    # header row
    outfile.write("measurement, len, sum, avg, stdev, rms, model, label, ")
    outfile.write(", ".join([f"freq {x:.2f}" for x in key_freqs]))
    outfile.write("\n")

    # now output all measurements, including key freqs
    for i, m in enumerate(measurements):
        label = m.label.replace(',', '_')
        model = m.settings.eeprom.model
        pr    = m.processed_reading
        proc  = np.array(pr.processed)

        len_  = len(proc)
        sum_  = sum(proc)
        avg   = np.mean(proc)
        stdev = np.std(proc)
        rms   = np.sqrt(np.mean(proc**2))

        # stringify magnitudes of key frequenceis
        group = re.sub(r' -.*', '', label)
        if group not in group_freqs:
            group_freqs[group] = {}

        mags = ''
        freq_mags = m.freq_mags
        for key_freq in key_freqs:
            mag = None
            for freq in freq_mags:
                if round(freq, 2) == key_freq:
                    # if multiple FFT frequencies round to the same 0.01, take the highest magnitude
                    mag = freq_mags[freq] if mag is None else max(mag, freq_mags[freq])
            if mag is None:
                mags += ', '
            else:
                mags += f', {mag:.2f}' 
                if key_freq not in group_freqs[group]:
                    group_freqs[group][key_freq] = []
                group_freqs[group][key_freq].append(mag)

        outfile.write(f"{i}, {len_}, {sum_:.2f}, {avg:.2f}, {stdev:.2f}, {rms:.2f}, {model}, {label}, {mags}\n")

with open(f"fft-summary-{basename}.csv", "w") as outfile:
    # header row
    outfile.write("file, freq, " + ", ".join([group for group in group_freqs]) + "\n")

    # iterate over a fixed range of frequencies (simplifies comparative data)
    freq = 0.10
    while freq <= 0.35: 
        outfile.write(f"{basename}, {freq:.2f}")
        for group in group_freqs:
            if freq in group_freqs[group]:
                mags = group_freqs[group][freq]
                outfile.write(f", {np.median(mags):.2f}")
            else:
                outfile.write(", ")
        outfile.write("\n")

        freq = round(freq + 0.01, 2)
