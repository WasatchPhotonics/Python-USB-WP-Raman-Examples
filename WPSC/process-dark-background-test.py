#!/usr/bin/env python
"""
This script is provided to post-process DarkBackgroundTest.csv files generated by
WPSC. Those files typically provide 100ea dark spectra at multiple integration 
times, such as 10, 100 and 1000ms. It also may include dark spectra collected 
while the laser is OFF vs when the laser is ON.

This script applies an FFT to each dark spectrum to look for sinusoidal pattern 
noise (for instance, being leaked into the detector readout from the laser 
electronics).

This script is not considered production-ready for any particular purpose, and is
only recommended for quick-and-dirty R&D analysis or as an example of how Python
scripts can leverage ENLIGHTEN classes to quickly load WPSC files.

invocation:

$ export PYTHONPATH=$HOME/work/code/enlighten:$HOME/work/code/Wasatch.PY:$HOME/work/code/jcamp:$HOME/work/code/SPyC_Writer
$ python process-dark-background-test.py file.csv

"""

import re, os, sys, math, logging, argparse
import numpy as np
import matplotlib.pyplot as plt

from enlighten.parser.ExportFileParser import ExportFileParser
from wasatch import applog

args = None

def process_fft(a, label):
    """ Return a dict of {freq -> mag} for top n magnitudes (positive frequencies only) """
    data = np.fft.fft(a)

    len_ = len(a)
    freqs = np.fft.fftfreq(len_)
    mags = np.array( [ math.sqrt( v.real * v.real + v.imag * v.imag ) for v in data ] )

    # pop the zero'th element -- this simply contains the sum of all pixels
    freqs = freqs[1:]
    mags = mags[1:]

    # sort both by freq in ascending order
    indices = np.argsort(freqs)
    freqs = freqs[indices]
    mags = mags[indices]

    # graphing code for debugging 
    if args.plot:
        plt.clf()
        fig, (spectrum, analysis) = plt.subplots(1, 2, figsize=(15, 5))
        fig.suptitle(label)
        spectrum.plot(a)
        analysis.plot(freqs, mags)
        plt.draw()
        plt.pause(1)
        plt.close(fig)

    return freqs, mags

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument("--plot", action="store_true", help="graph FFT")
(args, filenames) = parser.parse_known_args(sys.argv[1:])

if args.plot:
    plt.ion()

filename = filenames[0]
basename = re.sub(r'\.csv', '', filename)
efp = ExportFileParser(ctl=None, pathname=filename)
measurements = efp.parse()

groups = {}
with open(f"table-{basename}.csv", "w") as outfile:
    # header row
    outfile.write("measurement, len, sum, avg, stdev, rms, model, label, ")
    finished_header = False

    # now output all measurements, including key freqs
    for i, m in enumerate(measurements):
        label = m.label.replace(',', '_')
        model = m.settings.eeprom.model
        pr    = m.processed_reading
        proc  = np.array(pr.raw)

        len_  = len(proc)
        sum_  = sum(proc)
        avg   = np.mean(proc)
        stdev = np.std(proc)
        rms   = np.sqrt(np.mean(proc**2))

        freqs, mags = process_fft(proc, label)

        if not finished_header:
            outfile.write(", ".join([f"freq {x:.3f}" for x in freqs]))
            outfile.write("\n")
            finished_header = True

        outfile.write(f"{i}, {len_}, {sum_:.2f}, {avg:.2f}, {stdev:.2f}, {rms:.2f}, {model}, {label}, " + ", ".join([f"{x:0.2f}" for x in mags]) + "\n")

        group = re.sub(r' -.*', '', label)
        if group not in groups:
            groups[group] = []
        groups[group].append(mags)

with open(f"fft-summary-{basename}.csv", "w") as outfile:
    # header row
    outfile.write("group, " + ", ".join([f"{x:0.3f}" for x in freqs]) + "\n")

    # median magnitudes
    for group in groups:
        mags = np.array(groups[group])
        medians = np.median(mags, axis=0)
        outfile.write(f"{group}-med, " + ", ".join([f"{x:0.2f}" for x in medians]) + "\n")

    # max magnitudes
    for group in groups:
        mags = np.array(groups[group])
        maxes = np.max(mags, axis=0)
        outfile.write(f"{group}-max, " + ", ".join([f"{x:0.2f}" for x in maxes]) + "\n")
